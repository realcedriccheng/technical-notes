# 内存地址、寻址相关概念

## MMIO

memory mapped IO，将 IO 设备映射到内存地址空间内，从而通过访问内存地址的方式访问 IO 设备。

## 地址

### 虚拟地址，Virtual Address，VA

操作系统提供给应用程序使用的内存地址。每个应用程序有自己的虚拟地址空间。

- 提高内存资源利用率
- 保证不同 APP 内存隔离（安全性、便于编程）

### 线性地址，Linear Address，LA

虚拟地址经过分段处理后的地址。虚拟地址包括段号+段内偏移量。从段号找到段基址，LA=段基址+段内偏移量（很类似于 ZNS 的 zone 内偏移）。由于现在已经不使用分段机制，段基址都是 0，所以线性地址等于虚拟地址。

### 物理地址，Physical Address，PA

线性地址经过 MMU 翻译转换成为物理地址。物理地址就是内存（RAM）使用的地址。

## MMU，Memory Management Unit，内存管理单元

用于将虚拟地址翻译成物理地址的一种硬件设备。

- 分段机制
  - MMU 找到虚拟地址（段号+段内偏移）段号对应的段基址，加上段内偏移量组成物理地址
- 分页机制
  - MMU 通过虚拟地址（一级页号+二级页号+……+页内偏移）的虚拟页号查询到对应物理页的起始地址，加上页内偏移量组成物理地址

## 分段机制和分页机制

### 分段机制

较早期的概念，现在已经不使用。问题：容易造成外部碎片
将虚拟地址空间划分为若干个段，每个段存储特定的内容。段之间在物理上可以不相邻，每个段有自己的起始地址（段基地址），通过段基地址+段内偏移量确定段内数据的物理地址。此外会检查偏移量是否越界。

### 分页机制

将虚拟地址空间和物理地址空间都按照连续等长的页 Page 来管理。通过页的起始地址+页内偏移量确定页内数据物理地址。也会检查偏移量越界问题。
解决了外部碎片的问题，因为任意一个逻辑页可以映射到任意一个物理页，逻辑上连续的页物理上可以不连续，这由页表来映射管理。
物理页也叫页框（page frame）。

### 页表和多级页表

为了实现任意一个逻辑页映射到任意一个物理页，需要页表来记录和管理这种映射关系。每个页表项长度为 8B。假如一个页 4KB，则一个页可以存储 512 条映射。因此这一个页可以管理 512*4KB=2MB 的空间。如果空间太大，那么需要的页表就太多，为此引进多级页表。
多级页表的实质在于，有一些逻辑页是没有用到的，因此不需要保存他们的映射表项。
![530792389.jpg](https://cdn.nlark.com/yuque/0/2024/jpeg/22949753/1720580694038-a838a650-9879-4274-bac9-8f190c8d074b.jpeg#averageHue=%23a5a7a5&from=url&id=taFsX&originHeight=2649&originWidth=2296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1681812&status=done&style=none&title=)
第一级页表也叫页目录，其地址保存在 CPU 的寄存器中，否则第一级就没办法找到，更不消说后面的了。
注意，这些页表都保存在内存中，也就都不是持久化的。通过页表查询到的地址也都是物理地址，因此每次查表都要访问内存。比较慢，可以用 TLB 缓存加速。

## 寻址

寻址由硬件和软件共同完成。

- 硬件：MMU 取出虚拟地址中的各级别页号，查询页表并加上偏移量得到物理地址
- 软件：页表的维护是软件完成的

注意，有可能会从不同的虚拟地址得到同样的物理地址，这取决于页表的映射。这叫做内存共享，是一种进程间通信方式，也是实现写时拷贝的基础。

## 内存映射的 linux 实现

### 线性地址的解释

Linux 将页表级别划分为 PGD、P4D、PUD、PMD、PT。分别是页全局目录 page global directory，页四级目录 page 4th dir，页上级目录 page upper dir ，页中级目录 page middle dir 和页表 page table。
并不是这些都用到了。具体的实现于硬件架构有关，